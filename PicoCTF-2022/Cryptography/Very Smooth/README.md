# Very Smooth - 300 pts

### Key ideas

- RSA Encryption
- Pollard p-1 factorization algorithm

---

## **Contents**

- [Overview](#overview)
- [Solution](#solution)

---

## Overview

### Description

> Forget safe primes... Here, we like to live life dangerously... >:)
> - [gen.py](./gen.py)
> - [output.txt](./output.txt)

### Hints
1. Don't look at me... Go ask Mr. Pollard if you need a hint!
---

## Solution

```
n = 809fbd8b667d664f01fe1b0387e0b424efe2035e2dec4d249ace30563d0e1a50050020880c2f01bad63b22e21125d780d887cffdb1165268e6be788cd49ad8a9a1d27482f1a8ccbb37adc0deee65d09f312ebaab854782e2411d917181fef63d478b7e25391ac10d0330cafcb5c8d859ee1e403be029ce5dd75f864deabe5a65645b099afb7af4ed84dd75d1e4b966e2a0662ece5409feeacb2a277ddf05b72153ff6f36524f7693cc432269b56bd8ab3d601844aef6a6130eaaec08f92f9816ed0e7781a23a043570364807bef579c1e9175e3fe2b1d8f52356230feea244ce1b88b2342c9e40b25583a1fe558bdfb3a7115a4c71a6f06b706419ce8e21a3e1
c = 74ce97c4712bc3827a9f6021089c093a7540a6280330a9ec7c6f446a88093c33a6b9a0a1fdf2cad96e32344970adbf26601d9baf2c4e9892dde435dc994bde4754fddbac47a475b3907a455c6f671484b473b5481080224406b1d48d48da5ba0d9fccdc5732cb64c0f02c32ddc1413f66bd95b8e5a929e5b1f14843bd8f5d4747a4aabcc64217a187db6913facce48f2019b5524633153ee40a4376960b7f669f331da29227fa9a8c09a58a6f3db7453dd89a6093c062ff95502cc7cca5ee497c8ec6265413f5d05d1b720b4eb620875b6f6d2a7958e2391835497a106f4c280cd1ca8b9605bbef5952b54dffc028c160c1495e5cd2957f6f2bbb2e868823b6a
```
Decrypting the hex into decimal, you get:
```
n = 16237273966836108120545793138084928629897229433359269853811036517408130990412315905032719835933027062806349026656969546706952216885700336241987462198846497866128469385845087257177806462075448795745255645036851304171294558034005843928223969132994878078039177397552489432477344386147809047379385391476398181005238431374419231170133622553608140144429529176425884181430778587305916041812649403278600142298567709101416482483848715249963954872862606729158862177500165861249872096563311618578664620929914771757453426377719542453172601160223030029072465102848163437163175061493978855848151566051932864722199692067969595188193
c = 14745518102990549993396231967010238598925487595737075102386714453833205999128514312343709574624206318784861363720687177363005855875685151439468735846849178516191250958513321418226126816220441622072775955158815313589415768991800850191022965127365179938485201605989512584224856864097157025326152644518178208895823099852290816783590694778428942262388258380986236466393936876338985762104185300723246403101722728880398442822038831738505696484763293920759869961241173735321794418273452100930321283190648733233608152140950572032537233345544765845396824420445758020322122287448862461166508152964791654530816373179266420063082
```
By googling `Pollard RSA`, you get two attacks: The [Pollard p-1 factorization algorithm](https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm) and [Pollard's Rho algorithm](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm). Referencing the title of the problem, "Very Smooth", you quickly realize that the method you are meant to use is the p-1 algorithm, as it is explicitly stated to be made for factoring numbers where p-1 is powersmooth.

So, the attack is as follows:

1. select a smoothness bound B
2. define M = the product of all numbers q^log_q(b), where q is primes less than B
3. randomly pick a coprime to n (note: we can actually fix a, e.g. if n is odd, then we can always select a = 2, random selection here is not imperative)
4. compute g = gcd(a^(M âˆ’ 1), n) (note: exponentiation can be done modulo n)
5. if 1 < g < n then return g
6. if g = 1 then select a larger B and go to step 2 or return failure
7. if g = n then select a smaller B and go to step 2 or return failure
```py
for i in primes:
    j = i ** math.floor(math.log(big_b, i))
    big_m *= j

p = math.gcd(pow(a, big_m - 1, n), n)
```

This returns a:

```
p = 90948561168129273993221811210960666354464742371830355918414414795363383976255151106886894591386782182287999383540600363376830936851508670766644159365209354955699549804449139999147729583415495583682823772357163202067648618287663470084801559563298980120877685812575934222306026078618063649035501461830981153927
```

From there, you can do your basic RSA decryption.

```py
q = n // p
carmichael = math.lcm(int(p - 1), int(q - 1))

e = 65537
d = pow(e, -1, carmichael)
print(f"d: {d}")

flag = pow(int(c), d, int(n))
print(f"flag: {flag}")
print(f"flag hex: {hex(int(flag))}")
```
Decoding the flag hex returns the flag.

<p align="center"><img src="https://static.wikia.nocookie.net/riskofrain2_gamepedia_en/images/e/e1/Weeping_Fungus.png"></p>
